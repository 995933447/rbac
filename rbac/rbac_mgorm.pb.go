// Code generated by protoc-gen-mgorm. DO NOT EDIT.
// Desc:
package rbac

import (
	"context"
	"fmt"
	"time"

	"github.com/995933447/mgorm"
	"go.mongodb.org/mongo-driver/bson"
	"go.mongodb.org/mongo-driver/mongo"
	"go.mongodb.org/mongo-driver/bson/primitive"
)

const (
	UserRoleDbName   = "rbac"
	UserRoleTbName   = "user_role"
	UserRoleConnName = "rbac"
)

// 索引
var userRoleIndexKeys = []string{
	"scope",
	"role_id",
}

var userRoleUniqueIndexKeys = []string{
	"user_id,role_id",
}

var userRoleExpireIndexKeys = []string{}

type UserRoleOrm struct {
	ID        primitive.ObjectID `json:"_id,omitempty" bson:"_id,omitempty"`
	UserId    uint64             `json:"user_id" bson:"user_id"`
	RoleId    uint64             `json:"role_id" bson:"role_id"`
	Status    int32              `json:"status" bson:"status"`
	Scope     string             `json:"scope" bson:"scope"`
	CreatedAt time.Time          `json:"created_at,omitempty" bson:"created_at,omitempty"`
	UpdatedAt time.Time          `json:"updated_at,omitempty" bson:"updated_at,omitempty"`
}

var userRoleOrmCache mgorm.Cache

func SetUserRoleOrmCache(cache mgorm.Cache) {
	userRoleOrmCache = cache
}

var onUserRoleOrmQueryDone mgorm.OnQueryDoneFunc

func SetUserRoleOrmOnQueryDone(fn mgorm.OnQueryDoneFunc) {
	onUserRoleOrmQueryDone = fn
}

func NewUserRoleModel() *UserRoleModel {
	cache := userRoleOrmCache
	if cache == nil {
		cache = mgorm.DefaultCache
	}
	orm := mgorm.NewOrm(
		UserRoleConnName,
		UserRoleDbName,
		UserRoleTbName,
		false,
		cache,
		userRoleIndexKeys,
		userRoleUniqueIndexKeys,
		userRoleExpireIndexKeys,
	)
	onQueryDoneFunc := onUserRoleOrmQueryDone
	if onQueryDoneFunc == nil {
		onQueryDoneFunc = mgorm.OnQueryDone
	}
	orm.SetOnQueryDone(onQueryDoneFunc)
	return &UserRoleModel{
		Model: mgorm.Model[UserRoleOrm]{
			Orm:    orm,
			Cached: false,
		},
	}
}

type UserRoleModel struct {
	mgorm.Model[UserRoleOrm]
}

func (m *UserRoleModel) NormalizeOrmForInsert(data *UserRoleOrm) {
	if data.ID.IsZero() {
		data.ID = primitive.NewObjectID()
	}
	if data.CreatedAt.IsZero() {
		data.CreatedAt = time.Now()
	}
	data.UpdatedAt = data.CreatedAt
}

func (m *UserRoleModel) InsertOneIgnoreConflict(ctx context.Context, data *UserRoleOrm) error {
	m.NormalizeOrmForInsert(data)
	_, err := m.Model.InsertOneIgnoreConflict(ctx, data)
	return err
}

func (m *UserRoleModel) InsertOne(ctx context.Context, data *UserRoleOrm) error {
	m.NormalizeOrmForInsert(data)
	_, err := m.Model.InsertOne(ctx, data)
	return err
}

func (m *UserRoleModel) InsertMany(ctx context.Context, dataList []*UserRoleOrm) error {
	var ins []any
	for _, data := range dataList {
		m.NormalizeOrmForInsert(data)
		ins = append(ins, data)
	}
	_, err := m.Model.InsertMany(ctx, ins)
	return err
}

func (m *UserRoleModel) GetCacheKeys(data *UserRoleOrm) []string {
	var cacheKeys []string
	cacheKeys = append(cacheKeys, fmt.Sprintf("_id:%s", data.ID.Hex()))
	cacheKeys = append(cacheKeys, fmt.Sprintf(
		"user_id:%d_role_id:%d", data.UserId, data.RoleId,
	))
	return cacheKeys
}

func (m *UserRoleModel) Update(ctx context.Context, data *UserRoleOrm) (*mongo.UpdateResult, error) {
	dataB, err := mgorm.ToBsonM(data)
	if err != nil {
		return nil, err
	}
	dataB["updated_at"] = time.Now()
	return m.Model.UpdateOne(ctx, bson.M{"_id": dataB["_id"]}, bson.M{"$set": dataB})
}

func (m *UserRoleModel) UpdateOne(ctx context.Context, filter any, data bson.M) (*mongo.UpdateResult, error) {
	data["updated_at"] = time.Now()
	return m.Model.UpdateOne(ctx, filter, bson.M{"$set": data})
}

func (m *UserRoleModel) UpdateMany(ctx context.Context, filter any, data bson.M) (*mongo.UpdateResult, error) {
	data["updated_at"] = time.Now()
	return m.Model.UpdateMany(ctx, filter, bson.M{"$set": data})
}

func (m *UserRoleModel) Upsert(ctx context.Context, filter any, data bson.M) (*mongo.UpdateResult, error) {
	insertData := bson.M{}
	data["updated_at"] = time.Now()
	insertData["created_at"] = time.Now()

	return m.Model.Upsert(ctx, filter, bson.M{"$set": data, "$setOnInsert": insertData})
}

func (m *UserRoleModel) UpInc(ctx context.Context, filter any, data bson.M) (*mongo.UpdateResult, error) {
	insertData := bson.M{}
	insertData["created_at"] = time.Now()

	return m.Model.Upsert(ctx, filter, bson.M{"$inc": data, "$set": bson.M{"updated_at": time.Now()}, "$setOnInsert": insertData})
}

func (m *UserRoleModel) UpAndInc(ctx context.Context, filter any, data, incdata bson.M) (*mongo.UpdateResult, error) {
	insertData := bson.M{}
	data["updated_at"] = time.Now()
	insertData["created_at"] = time.Now()

	return m.Model.Upsert(ctx, filter, bson.M{"$set": data, "$inc": incdata, "$setOnInsert": insertData})
}

func (m *UserRoleModel) DeleteOne(ctx context.Context, filter any) (*mongo.DeleteResult, error) {
	return m.Model.DeleteOne(ctx, filter)
}

func (m *UserRoleModel) DeleteMany(ctx context.Context, filter any) (*mongo.DeleteResult, error) {
	return m.Model.DeleteMany(ctx, filter)
}

func (m *UserRoleModel) UpdateOneByID(ctx context.Context, id string, data bson.M) (*mongo.UpdateResult, error) {
	objId, err := primitive.ObjectIDFromHex(id)
	if err != nil {
		return nil, err
	}
	data["updated_at"] = time.Now()
	return m.Model.UpdateOne(ctx, bson.M{"_id": objId}, bson.M{"$set": data})
}

func (m *UserRoleModel) DeleteOneByID(ctx context.Context, id string) (*mongo.DeleteResult, error) {
	objId, err := primitive.ObjectIDFromHex(id)
	if err != nil {
		return nil, err
	}

	return m.Model.DeleteOne(ctx, bson.M{"_id": objId})
}

func (m *UserRoleModel) FindOneByID(ctx context.Context, id string) (*UserRoleOrm, error) {
	var data UserRoleOrm
	objId, err := primitive.ObjectIDFromHex(id)
	if err != nil {
		return nil, err
	}
	filter := bson.M{"_id": objId}
	cacheKey := fmt.Sprintf("_id:%s", id)
	err = m.Model.FindOneByCacheKey(ctx, filter, cacheKey, &data)
	if err != nil {
		return nil, err
	}
	return &data, nil
}

func (m *UserRoleModel) UpdateOneByUserIdAndRoleId(ctx context.Context, userId uint64, roleId uint64, update bson.M) (*mongo.UpdateResult, error) {
	filter := bson.M{}
	var data UserRoleOrm
	filter["user_id"] = userId
	filter["role_id"] = roleId
	cacheKey := fmt.Sprintf(
		"user_id:%d_role_id:%d",
		userId, roleId,
	)
	err := m.Model.FindOneByCacheKey(ctx, filter, cacheKey, &data)
	if err == nil {
		defer m.Model.DelCache(m.GetCacheKeys(&data))
	} else if err != mongo.ErrNoDocuments {
		return nil, err
	}

	update["updated_at"] = time.Now()
	return m.Model.UpdateOne(ctx, filter, bson.M{"$set": update})
}

func (m *UserRoleModel) FindOneByUserIdAndRoleId(ctx context.Context, userId uint64, roleId uint64) (*UserRoleOrm, error) {
	var data UserRoleOrm
	filter := bson.M{}
	filter["user_id"] = userId
	filter["role_id"] = roleId
	cacheKey := fmt.Sprintf(
		"user_id:%d_role_id:%d",
		userId, roleId,
	)
	err := m.Model.FindOneByCacheKey(ctx, filter, cacheKey, &data)
	if err != nil {
		return nil, err
	}
	return &data, nil
}

func (m *UserRoleModel) DeleteOneByUserIdAndRoleId(ctx context.Context, userId uint64, roleId uint64) (*mongo.DeleteResult, error) {
	var data UserRoleOrm
	filter := bson.M{}
	filter["user_id"] = userId
	filter["role_id"] = roleId
	cacheKey := fmt.Sprintf(
		"user_id:%d_role_id:%d",
		userId, roleId,
	)
	err := m.Model.FindOneByCacheKey(ctx, filter, cacheKey, &data)
	if err == nil {
		defer m.Model.DelCache(m.GetCacheKeys(&data))
	} else if err != mongo.ErrNoDocuments {
		return nil, err
	}
	return m.Model.DeleteOne(ctx, filter)
}

func (m *UserRoleModel) FindManyByScope(ctx context.Context, scope string, sort bson.D, limit int64, selectors ...any) ([]*UserRoleOrm, error) {
	filter := bson.M{}
	filter["scope"] = scope
	return m.Model.FindMany(ctx, filter, sort, limit, selectors...)
}

func (m *UserRoleModel) FindManyPageByScope(ctx context.Context, scope string, sort bson.D, page, pageSize int64, selectors ...any) ([]*UserRoleOrm, error) {
	filter := bson.M{}
	filter["scope"] = scope
	skip := (page - 1) * pageSize
	if skip < 0 {
		skip = 0
	}
	return m.Model.FindManyByPage(ctx, filter, sort, skip, pageSize, selectors...)
}

func (m *UserRoleModel) FindAllByScope(ctx context.Context, scope string, sort bson.D, selectors ...any) ([]*UserRoleOrm, error) {
	filter := bson.M{}
	filter["scope"] = scope
	return m.Model.FindAllBySort(ctx, filter, sort, selectors...)
}

func (m *UserRoleModel) UpdateManyByScope(ctx context.Context, scope string, data bson.M) (*mongo.UpdateResult, error) {
	filter := bson.M{}
	filter["scope"] = scope
	return m.UpdateMany(ctx, filter, data)
}

func (m *UserRoleModel) DeleteManyByScope(ctx context.Context, scope string) (*mongo.DeleteResult, error) {
	filter := bson.M{}
	filter["scope"] = scope
	return m.DeleteMany(ctx, filter)
}

func (m *UserRoleModel) FindManyByRoleId(ctx context.Context, roleId uint64, sort bson.D, limit int64, selectors ...any) ([]*UserRoleOrm, error) {
	filter := bson.M{}
	filter["role_id"] = roleId
	return m.Model.FindMany(ctx, filter, sort, limit, selectors...)
}

func (m *UserRoleModel) FindManyPageByRoleId(ctx context.Context, roleId uint64, sort bson.D, page, pageSize int64, selectors ...any) ([]*UserRoleOrm, error) {
	filter := bson.M{}
	filter["role_id"] = roleId
	skip := (page - 1) * pageSize
	if skip < 0 {
		skip = 0
	}
	return m.Model.FindManyByPage(ctx, filter, sort, skip, pageSize, selectors...)
}

func (m *UserRoleModel) FindAllByRoleId(ctx context.Context, roleId uint64, sort bson.D, selectors ...any) ([]*UserRoleOrm, error) {
	filter := bson.M{}
	filter["role_id"] = roleId
	return m.Model.FindAllBySort(ctx, filter, sort, selectors...)
}

func (m *UserRoleModel) UpdateManyByRoleId(ctx context.Context, roleId uint64, data bson.M) (*mongo.UpdateResult, error) {
	filter := bson.M{}
	filter["role_id"] = roleId
	return m.UpdateMany(ctx, filter, data)
}

func (m *UserRoleModel) DeleteManyByRoleId(ctx context.Context, roleId uint64) (*mongo.DeleteResult, error) {
	filter := bson.M{}
	filter["role_id"] = roleId
	return m.DeleteMany(ctx, filter)
}

const (
	RoleDbName   = "rbac"
	RoleTbName   = "role"
	RoleConnName = "rbac"
)

// 索引
var roleIndexKeys = []string{
	"scope",
	"name",
}

var roleUniqueIndexKeys = []string{
	"role_id",
	"scope,name",
}

var roleExpireIndexKeys = []string{}

type RoleOrm struct {
	ID           primitive.ObjectID `json:"_id,omitempty" bson:"_id,omitempty"`
	RoleId       uint64             `json:"role_id" bson:"role_id"`
	Name         string             `json:"name" bson:"name"`
	Status       int32              `json:"status" bson:"status"`
	PermIds      []uint64           `json:"perm_ids" bson:"perm_ids"`
	Remark       string             `json:"remark" bson:"remark"`
	Scope        string             `json:"scope" bson:"scope"`
	IsSuperAdmin bool               `json:"is_super_admin" bson:"is_super_admin"`
	CreatedAt    time.Time          `json:"created_at,omitempty" bson:"created_at,omitempty"`
	UpdatedAt    time.Time          `json:"updated_at,omitempty" bson:"updated_at,omitempty"`
}

var roleOrmCache mgorm.Cache

func SetRoleOrmCache(cache mgorm.Cache) {
	roleOrmCache = cache
}

var onRoleOrmQueryDone mgorm.OnQueryDoneFunc

func SetRoleOrmOnQueryDone(fn mgorm.OnQueryDoneFunc) {
	onRoleOrmQueryDone = fn
}

func NewRoleModel() *RoleModel {
	cache := roleOrmCache
	if cache == nil {
		cache = mgorm.DefaultCache
	}
	orm := mgorm.NewOrm(
		RoleConnName,
		RoleDbName,
		RoleTbName,
		false,
		cache,
		roleIndexKeys,
		roleUniqueIndexKeys,
		roleExpireIndexKeys,
	)
	onQueryDoneFunc := onRoleOrmQueryDone
	if onQueryDoneFunc == nil {
		onQueryDoneFunc = mgorm.OnQueryDone
	}
	orm.SetOnQueryDone(onQueryDoneFunc)
	return &RoleModel{
		Model: mgorm.Model[RoleOrm]{
			Orm:    orm,
			Cached: false,
		},
	}
}

type RoleModel struct {
	mgorm.Model[RoleOrm]
}

func (m *RoleModel) NormalizeOrmForInsert(data *RoleOrm) {
	if data.ID.IsZero() {
		data.ID = primitive.NewObjectID()
	}
	if data.CreatedAt.IsZero() {
		data.CreatedAt = time.Now()
	}
	data.UpdatedAt = data.CreatedAt
}

func (m *RoleModel) InsertOneIgnoreConflict(ctx context.Context, data *RoleOrm) error {
	m.NormalizeOrmForInsert(data)
	_, err := m.Model.InsertOneIgnoreConflict(ctx, data)
	return err
}

func (m *RoleModel) InsertOne(ctx context.Context, data *RoleOrm) error {
	m.NormalizeOrmForInsert(data)
	_, err := m.Model.InsertOne(ctx, data)
	return err
}

func (m *RoleModel) InsertMany(ctx context.Context, dataList []*RoleOrm) error {
	var ins []any
	for _, data := range dataList {
		m.NormalizeOrmForInsert(data)
		ins = append(ins, data)
	}
	_, err := m.Model.InsertMany(ctx, ins)
	return err
}

func (m *RoleModel) GetCacheKeys(data *RoleOrm) []string {
	var cacheKeys []string
	cacheKeys = append(cacheKeys, fmt.Sprintf("_id:%s", data.ID.Hex()))
	cacheKeys = append(cacheKeys, fmt.Sprintf(
		"role_id:%d", data.RoleId,
	))
	cacheKeys = append(cacheKeys, fmt.Sprintf(
		"scope:%s_name:%s", data.Scope, data.Name,
	))
	return cacheKeys
}

func (m *RoleModel) Update(ctx context.Context, data *RoleOrm) (*mongo.UpdateResult, error) {
	dataB, err := mgorm.ToBsonM(data)
	if err != nil {
		return nil, err
	}
	dataB["updated_at"] = time.Now()
	return m.Model.UpdateOne(ctx, bson.M{"_id": dataB["_id"]}, bson.M{"$set": dataB})
}

func (m *RoleModel) UpdateOne(ctx context.Context, filter any, data bson.M) (*mongo.UpdateResult, error) {
	data["updated_at"] = time.Now()
	return m.Model.UpdateOne(ctx, filter, bson.M{"$set": data})
}

func (m *RoleModel) UpdateMany(ctx context.Context, filter any, data bson.M) (*mongo.UpdateResult, error) {
	data["updated_at"] = time.Now()
	return m.Model.UpdateMany(ctx, filter, bson.M{"$set": data})
}

func (m *RoleModel) Upsert(ctx context.Context, filter any, data bson.M) (*mongo.UpdateResult, error) {
	insertData := bson.M{}
	data["updated_at"] = time.Now()
	insertData["created_at"] = time.Now()

	return m.Model.Upsert(ctx, filter, bson.M{"$set": data, "$setOnInsert": insertData})
}

func (m *RoleModel) UpInc(ctx context.Context, filter any, data bson.M) (*mongo.UpdateResult, error) {
	insertData := bson.M{}
	insertData["created_at"] = time.Now()

	return m.Model.Upsert(ctx, filter, bson.M{"$inc": data, "$set": bson.M{"updated_at": time.Now()}, "$setOnInsert": insertData})
}

func (m *RoleModel) UpAndInc(ctx context.Context, filter any, data, incdata bson.M) (*mongo.UpdateResult, error) {
	insertData := bson.M{}
	data["updated_at"] = time.Now()
	insertData["created_at"] = time.Now()

	return m.Model.Upsert(ctx, filter, bson.M{"$set": data, "$inc": incdata, "$setOnInsert": insertData})
}

func (m *RoleModel) DeleteOne(ctx context.Context, filter any) (*mongo.DeleteResult, error) {
	return m.Model.DeleteOne(ctx, filter)
}

func (m *RoleModel) DeleteMany(ctx context.Context, filter any) (*mongo.DeleteResult, error) {
	return m.Model.DeleteMany(ctx, filter)
}

func (m *RoleModel) UpdateOneByID(ctx context.Context, id string, data bson.M) (*mongo.UpdateResult, error) {
	objId, err := primitive.ObjectIDFromHex(id)
	if err != nil {
		return nil, err
	}
	data["updated_at"] = time.Now()
	return m.Model.UpdateOne(ctx, bson.M{"_id": objId}, bson.M{"$set": data})
}

func (m *RoleModel) DeleteOneByID(ctx context.Context, id string) (*mongo.DeleteResult, error) {
	objId, err := primitive.ObjectIDFromHex(id)
	if err != nil {
		return nil, err
	}

	return m.Model.DeleteOne(ctx, bson.M{"_id": objId})
}

func (m *RoleModel) FindOneByID(ctx context.Context, id string) (*RoleOrm, error) {
	var data RoleOrm
	objId, err := primitive.ObjectIDFromHex(id)
	if err != nil {
		return nil, err
	}
	filter := bson.M{"_id": objId}
	cacheKey := fmt.Sprintf("_id:%s", id)
	err = m.Model.FindOneByCacheKey(ctx, filter, cacheKey, &data)
	if err != nil {
		return nil, err
	}
	return &data, nil
}

func (m *RoleModel) UpdateOneByRoleId(ctx context.Context, roleId uint64, update bson.M) (*mongo.UpdateResult, error) {
	filter := bson.M{}
	var data RoleOrm
	filter["role_id"] = roleId
	cacheKey := fmt.Sprintf(
		"role_id:%d",
		roleId,
	)
	err := m.Model.FindOneByCacheKey(ctx, filter, cacheKey, &data)
	if err == nil {
		defer m.Model.DelCache(m.GetCacheKeys(&data))
	} else if err != mongo.ErrNoDocuments {
		return nil, err
	}

	update["updated_at"] = time.Now()
	return m.Model.UpdateOne(ctx, filter, bson.M{"$set": update})
}

func (m *RoleModel) FindOneByRoleId(ctx context.Context, roleId uint64) (*RoleOrm, error) {
	var data RoleOrm
	filter := bson.M{}
	filter["role_id"] = roleId
	cacheKey := fmt.Sprintf(
		"role_id:%d",
		roleId,
	)
	err := m.Model.FindOneByCacheKey(ctx, filter, cacheKey, &data)
	if err != nil {
		return nil, err
	}
	return &data, nil
}

func (m *RoleModel) DeleteOneByRoleId(ctx context.Context, roleId uint64) (*mongo.DeleteResult, error) {
	var data RoleOrm
	filter := bson.M{}
	filter["role_id"] = roleId
	cacheKey := fmt.Sprintf(
		"role_id:%d",
		roleId,
	)
	err := m.Model.FindOneByCacheKey(ctx, filter, cacheKey, &data)
	if err == nil {
		defer m.Model.DelCache(m.GetCacheKeys(&data))
	} else if err != mongo.ErrNoDocuments {
		return nil, err
	}
	return m.Model.DeleteOne(ctx, filter)
}

func (m *RoleModel) UpdateOneByScopeAndName(ctx context.Context, scope string, name string, update bson.M) (*mongo.UpdateResult, error) {
	filter := bson.M{}
	var data RoleOrm
	filter["scope"] = scope
	filter["name"] = name
	cacheKey := fmt.Sprintf(
		"scope:%s_name:%s",
		scope, name,
	)
	err := m.Model.FindOneByCacheKey(ctx, filter, cacheKey, &data)
	if err == nil {
		defer m.Model.DelCache(m.GetCacheKeys(&data))
	} else if err != mongo.ErrNoDocuments {
		return nil, err
	}

	update["updated_at"] = time.Now()
	return m.Model.UpdateOne(ctx, filter, bson.M{"$set": update})
}

func (m *RoleModel) FindOneByScopeAndName(ctx context.Context, scope string, name string) (*RoleOrm, error) {
	var data RoleOrm
	filter := bson.M{}
	filter["scope"] = scope
	filter["name"] = name
	cacheKey := fmt.Sprintf(
		"scope:%s_name:%s",
		scope, name,
	)
	err := m.Model.FindOneByCacheKey(ctx, filter, cacheKey, &data)
	if err != nil {
		return nil, err
	}
	return &data, nil
}

func (m *RoleModel) DeleteOneByScopeAndName(ctx context.Context, scope string, name string) (*mongo.DeleteResult, error) {
	var data RoleOrm
	filter := bson.M{}
	filter["scope"] = scope
	filter["name"] = name
	cacheKey := fmt.Sprintf(
		"scope:%s_name:%s",
		scope, name,
	)
	err := m.Model.FindOneByCacheKey(ctx, filter, cacheKey, &data)
	if err == nil {
		defer m.Model.DelCache(m.GetCacheKeys(&data))
	} else if err != mongo.ErrNoDocuments {
		return nil, err
	}
	return m.Model.DeleteOne(ctx, filter)
}

func (m *RoleModel) FindManyByScope(ctx context.Context, scope string, sort bson.D, limit int64, selectors ...any) ([]*RoleOrm, error) {
	filter := bson.M{}
	filter["scope"] = scope
	return m.Model.FindMany(ctx, filter, sort, limit, selectors...)
}

func (m *RoleModel) FindManyPageByScope(ctx context.Context, scope string, sort bson.D, page, pageSize int64, selectors ...any) ([]*RoleOrm, error) {
	filter := bson.M{}
	filter["scope"] = scope
	skip := (page - 1) * pageSize
	if skip < 0 {
		skip = 0
	}
	return m.Model.FindManyByPage(ctx, filter, sort, skip, pageSize, selectors...)
}

func (m *RoleModel) FindAllByScope(ctx context.Context, scope string, sort bson.D, selectors ...any) ([]*RoleOrm, error) {
	filter := bson.M{}
	filter["scope"] = scope
	return m.Model.FindAllBySort(ctx, filter, sort, selectors...)
}

func (m *RoleModel) UpdateManyByScope(ctx context.Context, scope string, data bson.M) (*mongo.UpdateResult, error) {
	filter := bson.M{}
	filter["scope"] = scope
	return m.UpdateMany(ctx, filter, data)
}

func (m *RoleModel) DeleteManyByScope(ctx context.Context, scope string) (*mongo.DeleteResult, error) {
	filter := bson.M{}
	filter["scope"] = scope
	return m.DeleteMany(ctx, filter)
}

func (m *RoleModel) FindManyByName(ctx context.Context, name string, sort bson.D, limit int64, selectors ...any) ([]*RoleOrm, error) {
	filter := bson.M{}
	filter["name"] = name
	return m.Model.FindMany(ctx, filter, sort, limit, selectors...)
}

func (m *RoleModel) FindManyPageByName(ctx context.Context, name string, sort bson.D, page, pageSize int64, selectors ...any) ([]*RoleOrm, error) {
	filter := bson.M{}
	filter["name"] = name
	skip := (page - 1) * pageSize
	if skip < 0 {
		skip = 0
	}
	return m.Model.FindManyByPage(ctx, filter, sort, skip, pageSize, selectors...)
}

func (m *RoleModel) FindAllByName(ctx context.Context, name string, sort bson.D, selectors ...any) ([]*RoleOrm, error) {
	filter := bson.M{}
	filter["name"] = name
	return m.Model.FindAllBySort(ctx, filter, sort, selectors...)
}

func (m *RoleModel) UpdateManyByName(ctx context.Context, name string, data bson.M) (*mongo.UpdateResult, error) {
	filter := bson.M{}
	filter["name"] = name
	return m.UpdateMany(ctx, filter, data)
}

func (m *RoleModel) DeleteManyByName(ctx context.Context, name string) (*mongo.DeleteResult, error) {
	filter := bson.M{}
	filter["name"] = name
	return m.DeleteMany(ctx, filter)
}

const (
	PermDbName   = "rbac"
	PermTbName   = "perm"
	PermConnName = "rbac"
)

// 索引
var permIndexKeys = []string{
	"scope",
	"name",
	"pid",
}

var permUniqueIndexKeys = []string{
	"perm_id",
	"perm_id,resource_route",
	"scope,resource_route",
	"scope,name",
}

var permExpireIndexKeys = []string{}

type PermOrm struct {
	ID               primitive.ObjectID    `json:"_id,omitempty" bson:"_id,omitempty"`
	PermId           uint64                `json:"perm_id" bson:"perm_id"`
	Name             string                `json:"name" bson:"name"`
	ResourceRoute    string                `json:"resource_route" bson:"resource_route"`
	ResourceServices []*ResourceServiceOrm `json:"resource_services" bson:"resource_services"`
	Scope            string                `json:"scope" bson:"scope"`
	Pid              uint64                `json:"pid" bson:"pid"`
	ResourceType     int32                 `json:"resource_type" bson:"resource_type"`
	Extra            string                `json:"extra" bson:"extra"`
	CreatedAt        time.Time             `json:"created_at,omitempty" bson:"created_at,omitempty"`
	UpdatedAt        time.Time             `json:"updated_at,omitempty" bson:"updated_at,omitempty"`
}

var permOrmCache mgorm.Cache

func SetPermOrmCache(cache mgorm.Cache) {
	permOrmCache = cache
}

var onPermOrmQueryDone mgorm.OnQueryDoneFunc

func SetPermOrmOnQueryDone(fn mgorm.OnQueryDoneFunc) {
	onPermOrmQueryDone = fn
}

func NewPermModel() *PermModel {
	cache := permOrmCache
	if cache == nil {
		cache = mgorm.DefaultCache
	}
	orm := mgorm.NewOrm(
		PermConnName,
		PermDbName,
		PermTbName,
		false,
		cache,
		permIndexKeys,
		permUniqueIndexKeys,
		permExpireIndexKeys,
	)
	onQueryDoneFunc := onPermOrmQueryDone
	if onQueryDoneFunc == nil {
		onQueryDoneFunc = mgorm.OnQueryDone
	}
	orm.SetOnQueryDone(onQueryDoneFunc)
	return &PermModel{
		Model: mgorm.Model[PermOrm]{
			Orm:    orm,
			Cached: false,
		},
	}
}

type PermModel struct {
	mgorm.Model[PermOrm]
}

func (m *PermModel) NormalizeOrmForInsert(data *PermOrm) {
	if data.ID.IsZero() {
		data.ID = primitive.NewObjectID()
	}
	if data.CreatedAt.IsZero() {
		data.CreatedAt = time.Now()
	}
	data.UpdatedAt = data.CreatedAt
}

func (m *PermModel) InsertOneIgnoreConflict(ctx context.Context, data *PermOrm) error {
	m.NormalizeOrmForInsert(data)
	_, err := m.Model.InsertOneIgnoreConflict(ctx, data)
	return err
}

func (m *PermModel) InsertOne(ctx context.Context, data *PermOrm) error {
	m.NormalizeOrmForInsert(data)
	_, err := m.Model.InsertOne(ctx, data)
	return err
}

func (m *PermModel) InsertMany(ctx context.Context, dataList []*PermOrm) error {
	var ins []any
	for _, data := range dataList {
		m.NormalizeOrmForInsert(data)
		ins = append(ins, data)
	}
	_, err := m.Model.InsertMany(ctx, ins)
	return err
}

func (m *PermModel) GetCacheKeys(data *PermOrm) []string {
	var cacheKeys []string
	cacheKeys = append(cacheKeys, fmt.Sprintf("_id:%s", data.ID.Hex()))
	cacheKeys = append(cacheKeys, fmt.Sprintf(
		"perm_id:%d", data.PermId,
	))
	cacheKeys = append(cacheKeys, fmt.Sprintf(
		"perm_id:%d_resource_route:%s", data.PermId, data.ResourceRoute,
	))
	cacheKeys = append(cacheKeys, fmt.Sprintf(
		"scope:%s_resource_route:%s", data.Scope, data.ResourceRoute,
	))
	cacheKeys = append(cacheKeys, fmt.Sprintf(
		"scope:%s_name:%s", data.Scope, data.Name,
	))
	return cacheKeys
}

func (m *PermModel) Update(ctx context.Context, data *PermOrm) (*mongo.UpdateResult, error) {
	dataB, err := mgorm.ToBsonM(data)
	if err != nil {
		return nil, err
	}
	dataB["updated_at"] = time.Now()
	return m.Model.UpdateOne(ctx, bson.M{"_id": dataB["_id"]}, bson.M{"$set": dataB})
}

func (m *PermModel) UpdateOne(ctx context.Context, filter any, data bson.M) (*mongo.UpdateResult, error) {
	data["updated_at"] = time.Now()
	return m.Model.UpdateOne(ctx, filter, bson.M{"$set": data})
}

func (m *PermModel) UpdateMany(ctx context.Context, filter any, data bson.M) (*mongo.UpdateResult, error) {
	data["updated_at"] = time.Now()
	return m.Model.UpdateMany(ctx, filter, bson.M{"$set": data})
}

func (m *PermModel) Upsert(ctx context.Context, filter any, data bson.M) (*mongo.UpdateResult, error) {
	insertData := bson.M{}
	data["updated_at"] = time.Now()
	insertData["created_at"] = time.Now()

	return m.Model.Upsert(ctx, filter, bson.M{"$set": data, "$setOnInsert": insertData})
}

func (m *PermModel) UpInc(ctx context.Context, filter any, data bson.M) (*mongo.UpdateResult, error) {
	insertData := bson.M{}
	insertData["created_at"] = time.Now()

	return m.Model.Upsert(ctx, filter, bson.M{"$inc": data, "$set": bson.M{"updated_at": time.Now()}, "$setOnInsert": insertData})
}

func (m *PermModel) UpAndInc(ctx context.Context, filter any, data, incdata bson.M) (*mongo.UpdateResult, error) {
	insertData := bson.M{}
	data["updated_at"] = time.Now()
	insertData["created_at"] = time.Now()

	return m.Model.Upsert(ctx, filter, bson.M{"$set": data, "$inc": incdata, "$setOnInsert": insertData})
}

func (m *PermModel) DeleteOne(ctx context.Context, filter any) (*mongo.DeleteResult, error) {
	return m.Model.DeleteOne(ctx, filter)
}

func (m *PermModel) DeleteMany(ctx context.Context, filter any) (*mongo.DeleteResult, error) {
	return m.Model.DeleteMany(ctx, filter)
}

func (m *PermModel) UpdateOneByID(ctx context.Context, id string, data bson.M) (*mongo.UpdateResult, error) {
	objId, err := primitive.ObjectIDFromHex(id)
	if err != nil {
		return nil, err
	}
	data["updated_at"] = time.Now()
	return m.Model.UpdateOne(ctx, bson.M{"_id": objId}, bson.M{"$set": data})
}

func (m *PermModel) DeleteOneByID(ctx context.Context, id string) (*mongo.DeleteResult, error) {
	objId, err := primitive.ObjectIDFromHex(id)
	if err != nil {
		return nil, err
	}

	return m.Model.DeleteOne(ctx, bson.M{"_id": objId})
}

func (m *PermModel) FindOneByID(ctx context.Context, id string) (*PermOrm, error) {
	var data PermOrm
	objId, err := primitive.ObjectIDFromHex(id)
	if err != nil {
		return nil, err
	}
	filter := bson.M{"_id": objId}
	cacheKey := fmt.Sprintf("_id:%s", id)
	err = m.Model.FindOneByCacheKey(ctx, filter, cacheKey, &data)
	if err != nil {
		return nil, err
	}
	return &data, nil
}

func (m *PermModel) UpdateOneByPermId(ctx context.Context, permId uint64, update bson.M) (*mongo.UpdateResult, error) {
	filter := bson.M{}
	var data PermOrm
	filter["perm_id"] = permId
	cacheKey := fmt.Sprintf(
		"perm_id:%d",
		permId,
	)
	err := m.Model.FindOneByCacheKey(ctx, filter, cacheKey, &data)
	if err == nil {
		defer m.Model.DelCache(m.GetCacheKeys(&data))
	} else if err != mongo.ErrNoDocuments {
		return nil, err
	}

	update["updated_at"] = time.Now()
	return m.Model.UpdateOne(ctx, filter, bson.M{"$set": update})
}

func (m *PermModel) FindOneByPermId(ctx context.Context, permId uint64) (*PermOrm, error) {
	var data PermOrm
	filter := bson.M{}
	filter["perm_id"] = permId
	cacheKey := fmt.Sprintf(
		"perm_id:%d",
		permId,
	)
	err := m.Model.FindOneByCacheKey(ctx, filter, cacheKey, &data)
	if err != nil {
		return nil, err
	}
	return &data, nil
}

func (m *PermModel) DeleteOneByPermId(ctx context.Context, permId uint64) (*mongo.DeleteResult, error) {
	var data PermOrm
	filter := bson.M{}
	filter["perm_id"] = permId
	cacheKey := fmt.Sprintf(
		"perm_id:%d",
		permId,
	)
	err := m.Model.FindOneByCacheKey(ctx, filter, cacheKey, &data)
	if err == nil {
		defer m.Model.DelCache(m.GetCacheKeys(&data))
	} else if err != mongo.ErrNoDocuments {
		return nil, err
	}
	return m.Model.DeleteOne(ctx, filter)
}

func (m *PermModel) UpdateOneByPermIdAndResourceRoute(ctx context.Context, permId uint64, resourceRoute string, update bson.M) (*mongo.UpdateResult, error) {
	filter := bson.M{}
	var data PermOrm
	filter["perm_id"] = permId
	filter["resource_route"] = resourceRoute
	cacheKey := fmt.Sprintf(
		"perm_id:%d_resource_route:%s",
		permId, resourceRoute,
	)
	err := m.Model.FindOneByCacheKey(ctx, filter, cacheKey, &data)
	if err == nil {
		defer m.Model.DelCache(m.GetCacheKeys(&data))
	} else if err != mongo.ErrNoDocuments {
		return nil, err
	}

	update["updated_at"] = time.Now()
	return m.Model.UpdateOne(ctx, filter, bson.M{"$set": update})
}

func (m *PermModel) FindOneByPermIdAndResourceRoute(ctx context.Context, permId uint64, resourceRoute string) (*PermOrm, error) {
	var data PermOrm
	filter := bson.M{}
	filter["perm_id"] = permId
	filter["resource_route"] = resourceRoute
	cacheKey := fmt.Sprintf(
		"perm_id:%d_resource_route:%s",
		permId, resourceRoute,
	)
	err := m.Model.FindOneByCacheKey(ctx, filter, cacheKey, &data)
	if err != nil {
		return nil, err
	}
	return &data, nil
}

func (m *PermModel) DeleteOneByPermIdAndResourceRoute(ctx context.Context, permId uint64, resourceRoute string) (*mongo.DeleteResult, error) {
	var data PermOrm
	filter := bson.M{}
	filter["perm_id"] = permId
	filter["resource_route"] = resourceRoute
	cacheKey := fmt.Sprintf(
		"perm_id:%d_resource_route:%s",
		permId, resourceRoute,
	)
	err := m.Model.FindOneByCacheKey(ctx, filter, cacheKey, &data)
	if err == nil {
		defer m.Model.DelCache(m.GetCacheKeys(&data))
	} else if err != mongo.ErrNoDocuments {
		return nil, err
	}
	return m.Model.DeleteOne(ctx, filter)
}

func (m *PermModel) UpdateOneByScopeAndResourceRoute(ctx context.Context, scope string, resourceRoute string, update bson.M) (*mongo.UpdateResult, error) {
	filter := bson.M{}
	var data PermOrm
	filter["scope"] = scope
	filter["resource_route"] = resourceRoute
	cacheKey := fmt.Sprintf(
		"scope:%s_resource_route:%s",
		scope, resourceRoute,
	)
	err := m.Model.FindOneByCacheKey(ctx, filter, cacheKey, &data)
	if err == nil {
		defer m.Model.DelCache(m.GetCacheKeys(&data))
	} else if err != mongo.ErrNoDocuments {
		return nil, err
	}

	update["updated_at"] = time.Now()
	return m.Model.UpdateOne(ctx, filter, bson.M{"$set": update})
}

func (m *PermModel) FindOneByScopeAndResourceRoute(ctx context.Context, scope string, resourceRoute string) (*PermOrm, error) {
	var data PermOrm
	filter := bson.M{}
	filter["scope"] = scope
	filter["resource_route"] = resourceRoute
	cacheKey := fmt.Sprintf(
		"scope:%s_resource_route:%s",
		scope, resourceRoute,
	)
	err := m.Model.FindOneByCacheKey(ctx, filter, cacheKey, &data)
	if err != nil {
		return nil, err
	}
	return &data, nil
}

func (m *PermModel) DeleteOneByScopeAndResourceRoute(ctx context.Context, scope string, resourceRoute string) (*mongo.DeleteResult, error) {
	var data PermOrm
	filter := bson.M{}
	filter["scope"] = scope
	filter["resource_route"] = resourceRoute
	cacheKey := fmt.Sprintf(
		"scope:%s_resource_route:%s",
		scope, resourceRoute,
	)
	err := m.Model.FindOneByCacheKey(ctx, filter, cacheKey, &data)
	if err == nil {
		defer m.Model.DelCache(m.GetCacheKeys(&data))
	} else if err != mongo.ErrNoDocuments {
		return nil, err
	}
	return m.Model.DeleteOne(ctx, filter)
}

func (m *PermModel) UpdateOneByScopeAndName(ctx context.Context, scope string, name string, update bson.M) (*mongo.UpdateResult, error) {
	filter := bson.M{}
	var data PermOrm
	filter["scope"] = scope
	filter["name"] = name
	cacheKey := fmt.Sprintf(
		"scope:%s_name:%s",
		scope, name,
	)
	err := m.Model.FindOneByCacheKey(ctx, filter, cacheKey, &data)
	if err == nil {
		defer m.Model.DelCache(m.GetCacheKeys(&data))
	} else if err != mongo.ErrNoDocuments {
		return nil, err
	}

	update["updated_at"] = time.Now()
	return m.Model.UpdateOne(ctx, filter, bson.M{"$set": update})
}

func (m *PermModel) FindOneByScopeAndName(ctx context.Context, scope string, name string) (*PermOrm, error) {
	var data PermOrm
	filter := bson.M{}
	filter["scope"] = scope
	filter["name"] = name
	cacheKey := fmt.Sprintf(
		"scope:%s_name:%s",
		scope, name,
	)
	err := m.Model.FindOneByCacheKey(ctx, filter, cacheKey, &data)
	if err != nil {
		return nil, err
	}
	return &data, nil
}

func (m *PermModel) DeleteOneByScopeAndName(ctx context.Context, scope string, name string) (*mongo.DeleteResult, error) {
	var data PermOrm
	filter := bson.M{}
	filter["scope"] = scope
	filter["name"] = name
	cacheKey := fmt.Sprintf(
		"scope:%s_name:%s",
		scope, name,
	)
	err := m.Model.FindOneByCacheKey(ctx, filter, cacheKey, &data)
	if err == nil {
		defer m.Model.DelCache(m.GetCacheKeys(&data))
	} else if err != mongo.ErrNoDocuments {
		return nil, err
	}
	return m.Model.DeleteOne(ctx, filter)
}

func (m *PermModel) FindManyByScope(ctx context.Context, scope string, sort bson.D, limit int64, selectors ...any) ([]*PermOrm, error) {
	filter := bson.M{}
	filter["scope"] = scope
	return m.Model.FindMany(ctx, filter, sort, limit, selectors...)
}

func (m *PermModel) FindManyPageByScope(ctx context.Context, scope string, sort bson.D, page, pageSize int64, selectors ...any) ([]*PermOrm, error) {
	filter := bson.M{}
	filter["scope"] = scope
	skip := (page - 1) * pageSize
	if skip < 0 {
		skip = 0
	}
	return m.Model.FindManyByPage(ctx, filter, sort, skip, pageSize, selectors...)
}

func (m *PermModel) FindAllByScope(ctx context.Context, scope string, sort bson.D, selectors ...any) ([]*PermOrm, error) {
	filter := bson.M{}
	filter["scope"] = scope
	return m.Model.FindAllBySort(ctx, filter, sort, selectors...)
}

func (m *PermModel) UpdateManyByScope(ctx context.Context, scope string, data bson.M) (*mongo.UpdateResult, error) {
	filter := bson.M{}
	filter["scope"] = scope
	return m.UpdateMany(ctx, filter, data)
}

func (m *PermModel) DeleteManyByScope(ctx context.Context, scope string) (*mongo.DeleteResult, error) {
	filter := bson.M{}
	filter["scope"] = scope
	return m.DeleteMany(ctx, filter)
}

func (m *PermModel) FindManyByName(ctx context.Context, name string, sort bson.D, limit int64, selectors ...any) ([]*PermOrm, error) {
	filter := bson.M{}
	filter["name"] = name
	return m.Model.FindMany(ctx, filter, sort, limit, selectors...)
}

func (m *PermModel) FindManyPageByName(ctx context.Context, name string, sort bson.D, page, pageSize int64, selectors ...any) ([]*PermOrm, error) {
	filter := bson.M{}
	filter["name"] = name
	skip := (page - 1) * pageSize
	if skip < 0 {
		skip = 0
	}
	return m.Model.FindManyByPage(ctx, filter, sort, skip, pageSize, selectors...)
}

func (m *PermModel) FindAllByName(ctx context.Context, name string, sort bson.D, selectors ...any) ([]*PermOrm, error) {
	filter := bson.M{}
	filter["name"] = name
	return m.Model.FindAllBySort(ctx, filter, sort, selectors...)
}

func (m *PermModel) UpdateManyByName(ctx context.Context, name string, data bson.M) (*mongo.UpdateResult, error) {
	filter := bson.M{}
	filter["name"] = name
	return m.UpdateMany(ctx, filter, data)
}

func (m *PermModel) DeleteManyByName(ctx context.Context, name string) (*mongo.DeleteResult, error) {
	filter := bson.M{}
	filter["name"] = name
	return m.DeleteMany(ctx, filter)
}

func (m *PermModel) FindManyByPid(ctx context.Context, pid uint64, sort bson.D, limit int64, selectors ...any) ([]*PermOrm, error) {
	filter := bson.M{}
	filter["pid"] = pid
	return m.Model.FindMany(ctx, filter, sort, limit, selectors...)
}

func (m *PermModel) FindManyPageByPid(ctx context.Context, pid uint64, sort bson.D, page, pageSize int64, selectors ...any) ([]*PermOrm, error) {
	filter := bson.M{}
	filter["pid"] = pid
	skip := (page - 1) * pageSize
	if skip < 0 {
		skip = 0
	}
	return m.Model.FindManyByPage(ctx, filter, sort, skip, pageSize, selectors...)
}

func (m *PermModel) FindAllByPid(ctx context.Context, pid uint64, sort bson.D, selectors ...any) ([]*PermOrm, error) {
	filter := bson.M{}
	filter["pid"] = pid
	return m.Model.FindAllBySort(ctx, filter, sort, selectors...)
}

func (m *PermModel) UpdateManyByPid(ctx context.Context, pid uint64, data bson.M) (*mongo.UpdateResult, error) {
	filter := bson.M{}
	filter["pid"] = pid
	return m.UpdateMany(ctx, filter, data)
}

func (m *PermModel) DeleteManyByPid(ctx context.Context, pid uint64) (*mongo.DeleteResult, error) {
	filter := bson.M{}
	filter["pid"] = pid
	return m.DeleteMany(ctx, filter)
}

type ResourceServiceOrm struct {
	Service string `json:"service" bson:"service"`
	Extra   string `json:"extra" bson:"extra"`
}
